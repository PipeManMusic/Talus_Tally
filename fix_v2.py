import os
import json
from backend.models import Project, SubProject, WorkPackage, Task, Status

print("üöÄ Starting Pydantic V2 Upgrade & Repair...")

# ---------------------------------------------------------
# 1. SEED THE DATABASE (Pydantic V2 Style)
# ---------------------------------------------------------
try:
    project = Project(name="Project Talus - Bronco II")
    sub = SubProject(id="SP1", name="Electronics", priority=10)
    wp = WorkPackage(id="WP1", name="Navigation", importance=10)
    t1 = Task(id="T1", text="Buy GPS", budget_priority=8, estimated_cost=200.0)
    t2 = Task(id="T2", text="Install MapLibre", budget_priority=5, estimated_cost=0.0)

    wp.tasks = [t1, t2]
    sub.work_packages = [wp]
    project.sub_projects = [sub]

    os.makedirs("data", exist_ok=True)
    
    # THE FIX: Use model_dump_json(indent=4) instead of json(indent=4)
    with open("data/talus_master.json", "w") as f:
        f.write(project.model_dump_json(indent=4))
        
    print("‚úÖ Database seeded successfully (V2 Syntax).")

except TypeError as e:
    print(f"‚ùå Database Seed Failed: {e}")
    exit(1)

# ---------------------------------------------------------
# 2. UPGRADE backend/main.py TO V2
# ---------------------------------------------------------
main_py_content = r\"\"\"from fastapi import FastAPI, HTTPException
from .models import Project, Task, Status
from .engine import PriorityEngine
from .translator import MarkdownGenerator
from .injector import DocInjector
import json
import os

app = FastAPI(title="Talus Tally API")
DATA_FILE = "data/talus_master.json"
README_FILE = "README.md"

def load_project() -> Project:
    if not os.path.exists(DATA_FILE):
        return Project(sub_projects=[])
    with open(DATA_FILE, "r") as f:
        # V2 FIX: parse_obj -> model_validate
        return Project.model_validate(json.load(f))

def save_project(project: Project):
    with open(DATA_FILE, "w") as f:
        # V2 FIX: json(indent=4) -> model_dump_json(indent=4)
        f.write(project.model_dump_json(indent=4))

def trigger_roadmap_update(project: Project):
    generator = MarkdownGenerator()
    new_roadmap = generator.render(project)
    
    try:
        injector = DocInjector(README_FILE)
        success = injector.update_roadmap(new_roadmap)
        if success:
            print(f"‚úÖ Roadmap updated in {README_FILE}")
        else:
            print(f"‚ö†Ô∏è Roadmap update skipped (Markers not found in {README_FILE})")
    except Exception as e:
        print(f"‚ö†Ô∏è Failed to update Roadmap: {e}")

@app.get("/")
def read_root():
    return {"message": "Talus Tally API is Online"}

@app.get("/tasks")
def get_prioritized_tasks():
    project = load_project()
    engine = PriorityEngine()
    return engine.get_sorted_tasks(project)

@app.post("/tasks/{task_id}/complete")
def complete_task(task_id: str):
    project = load_project()
    found = False
    
    for sub_p in project.sub_projects:
        for wp in sub_p.work_packages:
            for task in wp.tasks:
                if task.id == task_id:
                    task.status = Status.COMPLETE
                    found = True
    
    if not found:
        raise HTTPException(status_code=404, detail="Task not found")
    
    save_project(project)
    trigger_roadmap_update(project)
    
    return {"status": "success", "message": f"Task {task_id} marked complete & Roadmap updated"}
\"\"\"

with open("backend/main.py", "w") as f:
    f.write(main_py_content)
print("‚úÖ backend/main.py upgraded to Pydantic V2.")

# ---------------------------------------------------------
# 3. REPAIR README.md (Restore Markers)
# ---------------------------------------------------------
T_START = "<" + "!-- TALLY_START --" + ">"
T_END   = "<" + "!-- TALLY_END --" + ">"

readme_content = f\"\"\"# Project Talus - Bronco II Restoration

## Project Overview
Restoring a classic Ford Bronco II using Financial Velocity to prioritize tasks.

## Roadmap
{T_START}
- [ ] Initial Task (This will be overwritten)
{T_END}

## Footer
*Generated by Talus Tally*
\"\"\"

with open("README.md", "w") as f:
    f.write(readme_content)
print("‚úÖ README.md repaired (Markers restored).")
